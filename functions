using DataFrames
# translation of the R code
# starting from the simplest

function vlag(X, p)
    ## This function create
    ## Z = [z_1 z_2 ... z_T]
    ## where
    ## z_t = (1 y_{t-1}' y_{t-2}' ... y_{t-p}')
    n = size(X, 1)
    m = size(X, 2)
    Z = zeros(Float64, n-p, m*p)
    for i=1:p
        @inbounds Z[:, (m*(i-1)+1):(m*i)] = X[(p+1-i):(n-i), :]
    end
    Z
end



function vlag2(X, p)
    ## This function create
    ## Z = [z_1 z_2 ... z_T]
    ## where
    ## z_t = (1 y_{t-1}' y_{t-2}' ... y_{t-p}')
    n = size(X, 1)
    m = size(X, 2)
    Z = zeros(Float64, n-p, m*p)
    for i = 1:p, j = 1:m
        for t = 1:n-p      
            @inbounds Z[t, j+(i-1)*m] = X[t+p-i, j]
        end
    end 
    Z
end


A = randn(220,100)
vlag(A, 2)-vlag2(A, 2)

@time vlag(A, 10);
@time vlag2(A, 10);

=========================================================

function setbvar (Y, p, h, constant, is.direct = false)
  if isdefined(:h)==false
    h = 1
  else
    if isdefined(:p)==false
      return("lag length should be > 0")
    else
      
      Yraw = reshape(Y, size(A)[1], size(A)[2])
      Traw = size(Y)[1]
      m = size(Y)[2]
      if is.direct
        Y1 = Yraw[(h+1-1):Traw, :]
        Y2 = Yraw[1:(Traw-h-1), :]
        Traw = Traw - h + 1
      else
        Y1 = Y2 = Yraw
      end
      
      # construct Y, X, Z
      # X is a (T x k)
      # Z is the block diagonal matrix
      out = DataFrame(out = bvar_data_work(Y1, Y2, Yraw, m, p, Traw, constant))
      out[:Y1] = Y1
      out[:Traw] = Traw
      out[:h] = h
      ##----------------------------OLS-------------------------------
      ## ols = bvar.ols(out[:Y][1], out[:X][1])
      # might get messy to pull the data out of the eventual dataframe,
      # a restructuralization might be good
      ols = NA
      out = DataFrame(ols = ols, data = out, constant = constant)      
    end
  end
  out
end

===============================================================

function priorBGR(vardata, lambda, constant, delta, coefsum)
  # PRIORS
  # Construct prior parameters using dummy observations as in BGR 
  # equation (5) page 75
  
  m = vardata[:m][1]
  n = m
  T = vardata[:T][1]
  p = vardata[:p][1]
  k = vardata[:k][1]
  Y = vardata[:Y][1]
  Yraw = vardata[:Yraw][1]
  constant = vardata[:constant][1]
  
  if isdefined(:delta)==false
    delta = 1
  end
  if length(delta)!=1
    if length(delta)!=m
      return("delta of the wrong dimension")
    else
      delta = rep(delta,m)
    end
  end
  
  # Get residual variances of univariate p-lag autoregressions
  # Here we just run the AR(p) model on each equation, ignoring the constans
  # and exogenous variables (if they have been specified in the original VAR model)
  
  # the AR model needed
  s.i = 
