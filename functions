# translation of the R code
# starting from the simplest

function vlag(X, p)
    ## This function create
    ## Z = [z_1 z_2 ... z_T]
    ## where
    ## z_t = (1 y_{t-1}' y_{t-2}' ... y_{t-p}')
    n = size(X, 1)
    m = size(X, 2)
    Z = zeros(Float64, n-p, m*p)
    ## reshape(zeros(Float64,T*m*p),T,m*p)
    # still didn't find a better the way to create matrices before filling them
    # could you give a hint on the differences between R and Julia in creating object before filling them?
    for i=1:p
        @inbounds Z[:, (m*(i-1)+1):(m*i)] = X[(p+1-i):(n-i), :]
    end
    Z
end



function vlag2(X, p)
    ## This function create
    ## Z = [z_1 z_2 ... z_T]
    ## where
    ## z_t = (1 y_{t-1}' y_{t-2}' ... y_{t-p}')
    n = size(X, 1)
    m = size(X, 2)
    Z = zeros(Float64, n-p, m*p)
    for i = 1:p, j = 1:m
        for t = 1:n-p      
            @inbounds Z[t, j+(i-1)*m] = X[t+p-i, j]
        end
    end 
    Z
end


A = randn(220,100)
vlag(A, 2)-vlag2(A, 2)

@time vlag(A, 10);
@time vlag2(A, 10);

=========================================================

function setbvar (Y, p, h, constant, is.direct = false)
  if isdefined(:h)==false
    h = 1
  else
    if isdefined(:p)==false
      return("lag length should be > 0")
    else
      
      Yraw = reshape(Y, size(A)[1], size(A)[2])
      Traw = size(Y)[1]
      m = size(Y)[2]
      if is.direct
        Y1 = Yraw[(h+1-1):Traw, :]
        Y2 = Yraw[1:(Traw-h-1), :]
        Traw = Traw - h + 1
      else
        Y1 = Y2 = Yraw
      end
      
      # construct Y, X, Z
      # X is a (T x k)
      # Z is the block diagonal matrix
      
      
      
