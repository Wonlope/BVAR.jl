using DataFrames
# translation of the R code
# starting from the simplest

++++++++++++++++++++++++++++++++++++++++++++
# my additions
type RegOut{V<:Float64}
  β::Matrix{V}
  errors::Matrix{V}
  forecasts::Matrix{V}
end

function OLS (y, x)
  Y = y
  X = x
  β = inv((X'*X))*X'*Y
  return(β)
end

function AR(y, p)
  T = length(y)
  Y = y[(p+1):end, :]
  X = Array(Float64, T-p, p)
  for ii in 1:p
    X[:, ii] = y[(p-ii+1):(T-ii), :]
  end
  β = OLS(Y, X)
  residuals = Y - X*β
  RegOut(β, residuals, zeros(Float64, 10,10))
  # forecasts are not added yet!!
end
# have to figure out how to export these from another file
+++++++++++++++++++++++++++++++++++++++++++++++++

function vlag(X, p)
    ## This function create
    ## Z = [z_1 z_2 ... z_T]
    ## where
    ## z_t = (1 y_{t-1}' y_{t-2}' ... y_{t-p}')
    n = size(X, 1)
    m = size(X, 2)
    Z = zeros(Float64, n-p, m*p)
    for i=1:p
        @inbounds Z[:, (m*(i-1)+1):(m*i)] = X[(p+1-i):(n-i), :]
    end
    Z
end



function vlag2(X, p)
    ## This function create
    ## Z = [z_1 z_2 ... z_T]
    ## where
    ## z_t = (1 y_{t-1}' y_{t-2}' ... y_{t-p}')
    n = size(X, 1)
    m = size(X, 2)
    Z = zeros(Float64, n-p, m*p)
    for i = 1:p, j = 1:m
        for t = 1:n-p
            @inbounds Z[t, j+(i-1)*m] = X[t+p-i, j]
        end
    end
    Z
end


A = randn(220,100)
vlag(A, 2)-vlag2(A, 2)

@time vlag(A, 10);
@time vlag2(A, 10);

=========================================================

function setbvar (Y, p, h, constant, is.direct = false)
  if isdefined(:h)==false
    h = 1
  else
    if isdefined(:p)==false
      return("lag length should be > 0")
    else

      Yraw = reshape(Y, size(A)[1], size(A)[2])
      Traw = size(Y)[1]
      m = size(Y)[2]
      if is.direct
        Y1 = Yraw[(h+1-1):Traw, :]
        Y2 = Yraw[1:(Traw-h-1), :]
        Traw = Traw - h + 1
      else
        Y1 = Y2 = Yraw
      end

      # construct Y, X, Z
      # X is a (T x k)
      # Z is the block diagonal matrix
      out = DataFrame(out = bvar_data_work(Y1, Y2, Yraw, m, p, Traw, constant))
      out[:Y1] = Y1
      out[:Traw] = Traw
      out[:h] = h
      ##----------------------------OLS-------------------------------
      ## ols = bvar.ols(out[:Y][1], out[:X][1])
      # might get messy to pull the data out of the eventual dataframe,
      # a restructuralization might be good
      ols = NA
      out = DataFrame(ols = ols, data = out, constant = constant)
    end
  end
  out
end

===============================================================

function priorBGR(vardata, lambda, constant, delta, coefsum)
  # PRIORS
  # Construct prior parameters using dummy observations as in BGR
  # equation (5) page 75

  m = vardata[:m][1]
  n = m
  T = vardata[:T][1]
  p = vardata[:p][1]
  k = vardata[:k][1]
  Y = vardata[:Y][1]
  Yraw = vardata[:Yraw][1]
  constant = vardata[:constant][1]

  if isdefined(:delta)==false
    delta = 1
  end
  if length(delta)!=1
    if length(delta)!=m
      return("delta of the wrong dimension")
    else
      delta = rep(delta,m)
    end
  end

  # Get residual variances of univariate p-lag autoregressions
  # Here we just run the AR(p) model on each equation, ignoring the constans
  # and exogenous variables (if they have been specified in the original VAR model)

  # the AR model needed
  s.i = Array(Float64, size(Yraw)[2])
  for i in 1:size(Yraw)[2]
    er = AR(Yraw[:, i], p).errors
    s.i[i] = (er'*er)/length(er)
  end

  # construct Xd
  Jp = diagm(1:p)
  dsl = diagm(sqrt(s.i))/lambda
  dsl2 = diagm(sqrt(s.i)*delta)/lambda
  epsilon = 0.001

  # cbind = hcat
  Xd1 = hcat(kron(Js,dls), zeros(Float64, m*p, 1))
  Xd2 = hcat(zeros(Float64, n, n*p), zeros(Float64, n, 1))
  Xd3 = hcat(zeros(Float64, 1, n*p), epsilon)

  Xd = vcat(Xd1, Xd2, Xd3)
  Yd = vcat(dsl2, zeros(Float64, n*(p-1), n), diagm(sqrt(s.i)), zeros(Float64, 1, n))

  if coefsum == true
    colmeans = Array(Float64, size(vardata.Yraw)[2]) # to be careful with notations of function output (to use types later)
    for i in 1:length(colmeans)
      colmeans[i] = mean(vardata.Yraw[:, i])
    end
    Ydc = diagm(delta*colmeans)/10*lambda
    Xdc = vcat(kron(ones(Float64, p),Ydc), zeros(Float64, m))
    Xd = vcat(Xd, Xdc')
    Yd = vcat(Yd, Ydc)
  end

  Omega0 = inv(Xd'*Xd)
  B0 = inv(Xd'*Xd)*(Xd'*Yd)
  Psi0 = (Yd-Xd*B0)'*(Yd-Xd*B0)
  # rearrange for the constant on top
  # return(list(B = B0, Psi = Psi0, Omega = Omega0, Xd = Xd, Yd = Yd))

end

===============================================================

